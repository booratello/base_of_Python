from functools import reduce
from itertools import count
from itertools import cycle
from math import factorial
from random import randrange


def task2():
    """
    Представлен список чисел. Необходимо вывести элементы исходного списка,значения которых больше предыдущего элемента.
    Подсказка:элементы, удовлетворяющие условию, оформить в виде списка. Для формирования списка использовать генератор.

    :return: None
    """
    start_list = [randrange(101) for _ in range(25)]
    print(f"Предоставлен следующий список:\n{start_list}")
    sorted_list = [start_list[i] for i in range(1, len(start_list)) if start_list[i - 1] < start_list[i]]
    print(f"Элементы списка, значения которых больше предыдущего элемента:\n{sorted_list}\n")


def task3():
    """
    Для чисел в пределах от 20 до 240 найти числа, кратные 20 или 21. Необходимо решить задание в одну строку.
    Подсказка: использовать функцию range() и генератор.

    :return: None
    """
    print(f"Получен следующий список из чисел, кратных 20 или 21 в пределах от 20 до 240 (включительно):\n"
          f"{[el for el in range(20, 241) if el % 20 == 0 or el % 21 == 0]}\n")


def task4():
    """
    Представлен список чисел. Определить элементы списка, не имеющие повторений. Сформировать итоговый массив чисел,
    соответствующих требованию. Элементы вывести в порядке их следования в исходном списке.
    Для выполнения задания обязательно использовать генератор.

    :return: None
    """
    start_list = [randrange(51) for _ in range(25)]
    print(f"Предоставлен следующий список:\n{start_list}")
    sorted_list = [el for el in start_list if start_list.count(el) == 1]
    print(f"Неповторяющиеся элементы списка в порядке, соответствующему их порядку в исходном списке:\n{sorted_list}\n")


def task5():
    """
    Реализовать формирование списка, используя функцию range() и возможности генератора. В список должны войти четные
    числа от 100 до 1000 (включая границы). Необходимо получить результат вычисления произведения всех элементов списка.
    Подсказка: использовать функцию reduce().

    :return: None
    """
    """
    - reduce() - функция, в котрую входит некая другая функция и параметры, которые к этой вложеной фунции будут
    применяться. Первый параметр после первого выполнения вложеной функции становится равным результату её выполнения.
    Второй параметр (и другие, если их больше двух) принимается равным следующему элементу из списка параметров.
    Так до тех пор, пока не будет перебран весь список параметров и не будет получено итоговое единичное значение.
    - lambda prev_el, el: prev_el * el - вложеная функция в функцию reduce(). Умножает первый элемент на второй.
    - [el for el in range(100, 1001, 2)] - список параметров, которые функция reduce() будет применять ко вложенной
    функции. Это список, заполняемый генератором из диапазона от 100 до 1000 включительно с шагом 2, т.е. для данного
    случая - чётными элементами из указаного диапазона занчений.
    """
    rand_list = [randrange(100, 1001, 2) for _ in range(randrange(5, 21))]
    print(f"Создадим спиок произвольной длины (от 5 до 20 элементов), каждый элемент которого является случайным\n"
          f"чётным числом в диапазоне от 100 до 1000:\n{rand_list}\n")
    print(f"В результате произведения всех элементов списка получено следующее число:\n"
          f"{reduce(lambda prev_el, el: prev_el * el, rand_list)}\n")


def task6():
    """
    Реализовать два небольших скрипта:
    а) бесконечный итератор, генерирующий целые числа, начиная с указанного,
    б) бесконечный итератор, повторяющий элементы некоторого списка, определенного заранее.
    Подсказка: использовать функцию count() и cycle() модуля itertools.

    :return: None
    """

    # Тот случай, когда диалог с пользователем и защита от дурака занимают 90% кода.

    def is_it_number(i):
        """
        Проверка, является ли введённая пользователем строка числом, за счёт переопределения её типа данных как int для
        дальнейшей работы с ней. В случае ошибки переопределения типа данных, у пользователя вновь запрашивается число.
        :param i: all types (almost), needs int
        :return: int
        """
        while True:
            try:
                i = int(i)
            except ValueError:
                i = input(f"Вместо {i} нужно целое число.\n")
                continue
            break
        return i

    user_answer = input("Какой скрипт будем выполнять (а/б)?\n").lower()
    while True:
        if user_answer not in {"а", "б"}:
            user_answer = input("Ошибка ввода. Введите \"а\" или \"б\" (без кавычек).\n")
            continue
        break

    if user_answer == "а":

        start_number = is_it_number(input("С какого целого числа начнём отсчёт?\n"))

        while True:
            step_number = is_it_number(input("Увеличивать (1) или уменьшать (-1) последующие числа?\n"))
            if step_number not in {-1, 1}:
                print("Ошибка ввода.")
                continue
            break

        while True:
            stop_number = is_it_number(input("До какого числа будем выводить последовательность?\n"))
            if (step_number == 1 and stop_number - start_number < 0) or \
                    (step_number == -1 and stop_number - start_number > 0) or start_number == stop_number:
                print("Ошибка ввода.\n"
                      "Для возрастающей последовательности это число должно быть больше начального.\n"
                      "Для убывающей последовательности это число должно быть меньше начального.\n"
                      "Это число не может быть равно начальному.")
                continue
            break

        for el in count(start_number, step_number):
            if stop_number - start_number > 0:
                if el > stop_number:
                    break
                else:
                    print(el)
            else:
                if el < stop_number:
                    break
                else:
                    print(el)

    else:
        start_list = [randrange(101) for _ in range(5)]
        print(f"Имеется следующий список:\n{start_list}\n")
        while True:
            stop_number = is_it_number(input("Сколько сделать повторений элементов списка?\n"))
            if stop_number <= 0:
                print("Ошибка ввода. Нужно положительное число.")
                continue
            break
        counter = 0
        for el in cycle(start_list):
            if counter > stop_number:
                break
            print(el)
            counter += 1


def task7():
    """
    Реализовать генератор с помощью функции с ключевым словом yield, создающим очередное значение. При вызове функции
    должен создаваться объект-генератор. Функция должна вызываться следующим образом: for el in fibo_gen().
    Функция отвечает за получение факториала числа, а в цикле необходимо выводить только первые 15 чисел.
    Подсказка: факториал числа n — произведение чисел от 1 до n. Например, факториал четырёх 4! = 1 * 2 * 3 * 4 = 24.

    :return: None
    """

    def fibo_gen():
        """
        Функция-генератор. При её вызове будет произведенно вычисление факториала первого числа из указаного диапазона,
        при втором вызове - второго и т.д., до конца диапазона.
        :return: generator
        """
        for i in range(1, 16):
            yield factorial(i)

    for el in fibo_gen():
        print(el)


while True:
    print("Задача [1]. Реализовать скрипт, в котором должна быть предусмотрена функция расчета заработной платы\n"
          "сотрудника. В расчете необходимо использовать формулу: (выработка в часах*ставка в час) + премия.\n"
          "Для выполнения расчета для конкретных значений необходимо запускать скрипт с параметрами.\n\n"
          "Задача [2]. Представлен список чисел. Необходимо вывести элементы исходного списка,значения которых больше\n"
          "предыдущего элемента. Подсказка: элементы, удовлетворяющие условию, оформить в виде списка.\n"
          "Для формирования списка использовать генератор.\n\n"
          "Задача [3]. Для чисел в пределах от 20 до 240 найти числа, кратные 20 или 21.\n"
          "Необходимо решить задание в одну строку. Подсказка: использовать функцию range() и генератор.\n\n"
          "Задача [4]. Представлен список чисел. Определить элементы списка, не имеющие повторений.\n"
          "Сформировать итоговый массив чисел, соответствующих требованию. Элементы вывести в порядке их следования в\n"
          "исходном списке. Для выполнения задания обязательно использовать генератор.\n\n"
          "Задача [5]. Реализовать формирование списка, используя функцию range() и возможности генератора.\n"
          "В список должны войти четные числа от 100 до 1000 (включая границы). Необходимо получить результат\n"
          "вычисления произведения всех элементов списка. Подсказка: использовать функцию reduce().\n\n"
          "Задача [6]. Реализовать два небольших скрипта:\n"
          "а) бесконечный итератор, генерирующий целые числа, начиная с указанного,\n"
          "б) бесконечный итератор, повторяющий элементы некоторого списка, определенного заранее.\n"
          "Подсказка: использовать функцию count() и cycle() модуля itertools.\n\n"
          "Задача [7]. Реализовать генератор с помощью функции с ключевым словом yield, создающим очередное значение.\n"
          "При вызове функции должен создаваться объект-генератор. Функция должна вызываться следующим образом:\n"
          "for el in fibo_gen(). Функция отвечает за получение факториала числа, а в цикле необходимо выводить только\n"
          "первые 15 чисел. Подсказка: факториал числа n — произведение чисел от 1 до n.\n"
          "Например, факториал четырёх 4! = 1 * 2 * 3 * 4 = 24.\n")

    menu_dict = {"2": task2, "3": task3, "4": task4, "5": task5, "6": task6, "7": task7}
    print("Задача 1 выполнена в отдельном файле \"base_of_Python_lesson4_hw_ex_1.py\".\n"
          "Его нужно вызвать через консоль с указанием 3 параметров.\n")
    try:
        menu_dict[input("Введите номер задачи. Для выхода нажмите любую клавишу, кроме 2-7.\n")]()
    except KeyError:
        break
